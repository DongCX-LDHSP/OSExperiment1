# 实验一

## 进程实验

### 解决办法

该实验内容较为简单，基于老师提供的代码敲一遍即可，可分为如下步骤：

1. 码代码
2. 编写脚本文件以便多次运行
3. 编译，使用`bash test.sh`运行脚本文件，观察记录实验结果
4. 将父进程中的`wait(NULL);`语句删去
5. 编译，使用`bash test.sh`运行脚本文件，观察记录实验结果，并与`3.`中实验结果进行比较

### 实验结论

1. `解决办法`的步骤`3.`的运行截图如下所示：子进程始终先于parent运行，图片中展示了局部的情况  
![子进程始终先于parent运行，图片中展示了局部的情况](https://github.com/DongCX-LDHSP/OSExperiment1/blob/master/ScreenShot/1%20-%20child%E5%A7%8B%E7%BB%88%E5%85%88%E4%BA%8Eparent%E6%89%A7%E8%A1%8C.png "child始终先于parent执行")

## 共享内存实验

### 解决办法

该实验内容同样较为简单，基于老师提供的代码敲一边即可，可分为如下步骤：

1. 码代码
2. 编写脚本文件以便多次运行
3. 编译，使用`bash test.sh`运行脚本文件，观察记录实验结果
4. 将父进程中的`wait(NULL);`语句删去
5. 编译，使用`bash test.sh`运行脚本文件，观察记录实验结果，并与`3.`中实验结果进行比较

### 实验结论

## 线程实验

### 解决办法

此实验内容考察对`pthread`库中的`pthread_join(tid, NULL)`函数的灵活运用，基于老师提供的代码敲一边，并按照如下步骤修改即可：

1. 码代码
2. 这里我沿用了老师单参数的`runner(void* param)`函数，所以特意构建了一个结构体，将信息打包起来传入函数内部
3. 结构体定义如下  
```c
typedef struct ARGV
{
    char* a;// 从控制台传入的参数信息
    pthread_t b;// 另外一个线程的`tid`
}ARGV;
```
4. 在创建子进程1之后，将相应信息赋值给结构体
5. 在创建子进程2时，将结构体作为参数传入
6. 在`runner02(void* param)`使用函数`pthread_join(tid, NULL)`进行绑定即可
7. 编译运行`gcc -o t thread.c -lpthread`，记录实验结果与不做绑定的运行结果进行比较

### 实验结论
